<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>golang面试题-基础 xianxin 志强网</title><meta name="keywords" content="面试,golang"><meta name="description" content="志强博客"><link rel="shortcut icon" type="image/x-icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/blog.css"><link rel="stylesheet" href="/libs/layui/css/layui.css"><script src="/libs/layui/layui.js"></script><script src="/js/blog.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body class="lay-blog"><div class="header"><div class="header-wrap"><h1 class="logo pull-left"><a href="/"><img src="/img/logo.png" alt="" class="logo-img"> <img src="/img/logo-text.png" alt="" class="logo-text"></a></h1><form class="layui-form blog-seach pull-left" method="get" action="https://www.google.com/search?"><div class="layui-form-item blog-sewrap"><div class="layui-input-block blog-sebox"><i class="layui-icon layui-icon-search"></i> <input type="text" name="q" lay-verify="title" autocomplete="off" class="layui-input"> <input type="hidden" name="source" value="https://www.zhiqiang.wang"></div></div></form><div class="blog-nav pull-right"><ul class="layui-nav pull-left"><li class="layui-nav-item"><a href="/">Home</a></li><li class="layui-nav-item"><a href="/about">About</a></li><li class="layui-nav-item"><a href="/archives">Archives</a></li><li class="layui-nav-item"><a href="/tags">Tags</a></li><li class="layui-nav-item"><a href="/sitemap.xml">RSS</a></li></ul></div></div></div><div class="container-wrap"><div class="container"><div class="contar-wrap"><div class="item"><div class="item-box"><p class="layui-breadcrumb" style="visibility:inherit"><a href="/">首页 </a><a href="/categories/golang/">golang</a></p><h3>golang面试题-基础</h3><h5>发布于：<span> 2024-04-23</span></h5><div class="post-meta"><a href="/tags/%E9%9D%A2%E8%AF%95/"><button type="button" class="layui-btn layui-btn-sm layui-bg-orange">#面试</button> </a><a href="/tags/golang/"><button type="button" class="layui-btn layui-btn-sm layui-bg-orange">#golang</button></a></div><hr class="layui-border-orange"><div class="layui-content"><p class="lay-content page-content"></p><h1 id="和-的区别？"><a href="#和-的区别？" class="headerlink" title="= 和 := 的区别？"></a><code>=</code> 和 <code>:=</code> 的区别？</h1><p>&#x3D;是赋值变量，:&#x3D;是定义变量。</p><h1 id="指针的作用"><a href="#指针的作用" class="headerlink" title="指针的作用"></a>指针的作用</h1><p>一个指针可以指向任意变量的地址，它所指向的地址在32位或64位机器上分别固定占4或8个字节。指针的作用有：</p><h2 id="获取变量的值"><a href="#获取变量的值" class="headerlink" title="获取变量的值"></a>获取变量的值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">  a := 1</span><br><span class="line">  p := &amp;a//取址&amp;</span><br><span class="line">  fmt.Printf(&quot;%d\n&quot;, *p);//取值*</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改变变量的值"><a href="#改变变量的值" class="headerlink" title="改变变量的值"></a>改变变量的值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func swap(a, b *int) &#123;</span><br><span class="line">   *a, *b = *b, *a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用指针替代值传入函数，比如类的接收器就是这样的。"><a href="#用指针替代值传入函数，比如类的接收器就是这样的。" class="headerlink" title="用指针替代值传入函数，比如类的接收器就是这样的。"></a>用指针替代值传入函数，比如类的接收器就是这样的。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type A struct&#123;&#125;</span><br><span class="line">func (a *A) fun()&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="Go-允许多个返回值吗？"><a href="#Go-允许多个返回值吗？" class="headerlink" title="Go 允许多个返回值吗？"></a>Go 允许多个返回值吗？</h1><p>可以。通常函数除了一般返回值还会返回一个error。</p><h1 id="Go-有异常类型吗？"><a href="#Go-有异常类型吗？" class="headerlink" title="Go 有异常类型吗？"></a>Go 有异常类型吗？</h1><p>有。Go用error类型代替try…catch语句，这样可以节省资源。同时增加代码可读性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> _, err := funcDemo()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用errors.New()来定义自己的异常。errors.Error()会返回异常的字符串表示。只要实现error接口就可以定义自己的异常，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type errorString struct &#123;</span><br><span class="line">	s string</span><br><span class="line">&#125;</span><br><span class="line">func (e *errorString) Error() string &#123;</span><br><span class="line">	return e.s</span><br><span class="line">&#125;</span><br><span class="line">// 多一个函数当作构造函数</span><br><span class="line">func New(text string) error &#123;</span><br><span class="line">	return &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="什么是协程（Goroutine）"><a href="#什么是协程（Goroutine）" class="headerlink" title="什么是协程（Goroutine）"></a>什么是协程（Goroutine）</h1><p>协程是用户态轻量级线程，它是线程调度的基本单位。通常在函数前加上go关键字就能实现并发。一个Goroutine会以一个很小的栈启动2KB或4KB，当遇到栈空间不足时，栈会自动伸缩， 因此可以轻易实现成千上万个goroutine同时启动。</p><h1 id="如何高效地拼接字符串"><a href="#如何高效地拼接字符串" class="headerlink" title="如何高效地拼接字符串"></a>如何高效地拼接字符串</h1><p>拼接字符串的方式有：<code>+</code> , <code>fmt.Sprintf</code> , <code>strings.Builder</code>, <code>bytes.Buffer</code>, <code>strings.Join</code></p><table><thead><tr><th>方式</th><th>解释</th></tr></thead><tbody><tr><td>+</td><td>使用<code>+</code>操作符进行拼接时，会对字符串进行遍历，计算并开辟一个新的空间来存储原来的两个字符串。</td></tr><tr><td>fmt.Sprintf</td><td>由于采用了接口参数，必须要用反射获取值，因此有性能损耗。</td></tr><tr><td>strings.Builder</td><td>用WriteString()进行拼接，内部实现是指针+切片，同时String()返回拼接后的字符串，它是直接把[]byte转换为string，从而避免变量拷贝。</td></tr><tr><td>bytes.Buffer</td><td><code>bytes.Buffer</code>是一个一个缓冲<code>byte</code>类型的缓冲器，这个缓冲器里存放着都是<code>byte</code>，<code>bytes.buffer</code>底层也是一个<code>[]byte</code>切片。</td></tr><tr><td>strings.join</td><td><code>strings.join</code>也是基于<code>strings.builder</code>来实现的,并且可以自定义分隔符，在join方法内调用了b.Grow(n)方法，这个是进行初步的容量分配，而前面计算的n的长度就是我们要拼接的slice的长度，因为我们传入切片长度固定，所以提前进行容量分配可以减少内存分配，很高效。</td></tr></tbody></table><p>性能比较：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func main()&#123;</span><br><span class="line">	a := []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;</span><br><span class="line">	//方式1：+</span><br><span class="line">	ret := a[0] + a[1] + a[2]</span><br><span class="line">	//方式2：fmt.Sprintf</span><br><span class="line">	ret := fmt.Sprintf(&quot;%s%s%s&quot;, a[0],a[1],a[2])</span><br><span class="line">	//方式3：strings.Builder</span><br><span class="line">	var sb strings.Builder</span><br><span class="line">	sb.WriteString(a[0])</span><br><span class="line">	sb.WriteString(a[1])</span><br><span class="line">	sb.WriteString(a[2])</span><br><span class="line">	ret := sb.String()</span><br><span class="line">	//方式4：bytes.Buffer</span><br><span class="line">	buf := new(bytes.Buffer)</span><br><span class="line">	buf.Write(a[0])</span><br><span class="line">	buf.Write(a[1])</span><br><span class="line">	buf.Write(a[2])</span><br><span class="line">	ret := buf.String()</span><br><span class="line">	//方式5：strings.Join</span><br><span class="line">	ret := strings.Join(a,&quot;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>strings.Join ≈ strings.Builder &gt; bytes.Buffer &gt; “+” &gt; fmt.Sprintf</p></blockquote><h1 id="什么是-rune-类型"><a href="#什么是-rune-类型" class="headerlink" title="什么是 rune 类型"></a>什么是 rune 类型</h1><p>ASCII 码只需要 7 bit 就可以完整地表示，但只能表示英文字母在内的128个字符，为了表示世界上大部分的文字系统，发明了 Unicode， 它是ASCII的超集，包含世界上书写系统中存在的所有字符，并为每个代码分配一个标准编号（称为Unicode CodePoint），在 Go 语言中称之为 rune，是 int32 类型的别名。</p><p>Go 语言中，字符串的底层表示是 byte (8 bit) 序列，而非 rune (32 bit) 序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sample := &quot;我爱GO&quot;</span><br><span class="line">runeSamp := []rune(sample)</span><br><span class="line">runeSamp[0] = &#x27;你&#x27;</span><br><span class="line">fmt.Println(string(runeSamp))  // &quot;你爱GO&quot;</span><br><span class="line">fmt.Println(len(runeSamp))  // 4</span><br></pre></td></tr></table></figure><h1 id="如何判断-map-中是否包含某个-key-？"><a href="#如何判断-map-中是否包含某个-key-？" class="headerlink" title="如何判断 map 中是否包含某个 key ？"></a>如何判断 map 中是否包含某个 key ？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var sample map[int]int</span><br><span class="line">if _, ok := sample[10]; ok &#123;</span><br><span class="line">	//TODO 存在逻辑</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	//TODO 不存在裸机</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Go-支持默认参数或可选参数吗？"><a href="#Go-支持默认参数或可选参数吗？" class="headerlink" title="Go 支持默认参数或可选参数吗？"></a>Go 支持默认参数或可选参数吗？</h1><p>不支持。但是可以利用结构体参数，或者…传入参数切片数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func sum(nums ...int) &#123;</span><br><span class="line">    total := 0</span><br><span class="line">    for _, num := range nums &#123;</span><br><span class="line">        total += num</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(total)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="defer-的执行顺序"><a href="#defer-的执行顺序" class="headerlink" title="defer 的执行顺序"></a>defer 的执行顺序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func test() int &#123;</span><br><span class="line">	i := 0</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		fmt.Println(&quot;defer2&quot;)</span><br><span class="line">	&#125;()</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		i += 1</span><br><span class="line">		fmt.Println(&quot;defer3&quot;)</span><br><span class="line">	&#125;()</span><br><span class="line">	return i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		fmt.Println(&quot;defter 1&quot;)</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(&quot;return&quot;, test())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//defer3</span><br><span class="line">//defer2</span><br><span class="line">//return 0</span><br><span class="line">//defter 1</span><br></pre></td></tr></table></figure><p>上面这个例子中，test返回值并没有修改，这是由于Go的返回机制决定的，执行Return语句后，Go会创建一个临时变量保存返回值。如果是有名返回（也就是指明返回值<code>func test() (i int)</code>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func test() (i int) &#123;</span><br><span class="line">	i = 0</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		i += 1</span><br><span class="line">		fmt.Println(&quot;defer2&quot;)</span><br><span class="line">	&#125;()</span><br><span class="line">	return i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(&quot;return&quot;, test())</span><br><span class="line">&#125;</span><br><span class="line">// defer2</span><br><span class="line">// return 1</span><br></pre></td></tr></table></figure><p>这个例子中，返回值被修改了。对于有名返回值的函数，执行 return 语句时，并不会再创建临时变量保存，因此，defer 语句修改了 i，即对返回值产生了影响。</p><h1 id="如何交换-2-个变量的值？"><a href="#如何交换-2-个变量的值？" class="headerlink" title="如何交换 2 个变量的值？"></a>如何交换 2 个变量的值？</h1><p>对于变量而言<code>a,b = b,a</code>； 对于指针而言<code>*a,*b = *b, *a</code></p><h1 id="Go-语言-tag-的用处？"><a href="#Go-语言-tag-的用处？" class="headerlink" title="Go 语言 tag 的用处？"></a>Go 语言 tag 的用处？</h1><p>tag可以为结构体成员提供属性。常见的：</p><ol><li>json序列化或反序列化时字段的名称</li><li>db: sqlx模块中对应的数据库字段名</li><li>form: gin框架中对应的前端的数据字段名</li><li>binding: 搭配 form 使用, 默认如果没查找到结构体中的某个字段则不报错值为空, binding为 required 代表没找到返回错误给前端</li></ol><h1 id="如何获取一个结构体的所有tag？"><a href="#如何获取一个结构体的所有tag？" class="headerlink" title="如何获取一个结构体的所有tag？"></a>如何获取一个结构体的所有tag？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Author struct &#123;</span><br><span class="line">	Name         int      `json:&quot;name&quot;`</span><br><span class="line">	Publications []string `json:&quot;publications,omitempty&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	t := reflect.TypeOf(Author&#123;&#125;)</span><br><span class="line">	for i := 0; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		name := t.Field(i).Name</span><br><span class="line">		s, _ := t.FieldByName(name)</span><br><span class="line">		fmt.Println(name, s.Tag)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中，<code>reflect.TypeOf</code>方法获取对象的类型，之后<code>NumField()</code>获取结构体成员的数量。 通过<code>Field(i)</code>获取第i个成员的名字。 再通过其<code>Tag</code> 方法获得标签。</p><h1 id="如何判断-2-个字符串切片（slice-是相等的？"><a href="#如何判断-2-个字符串切片（slice-是相等的？" class="headerlink" title="如何判断 2 个字符串切片（slice) 是相等的？"></a>如何判断 2 个字符串切片（slice) 是相等的？</h1><p><code>reflect.DeepEqual()</code> ， 但反射非常影响性能。</p><h1 id="结构体打印时，-v-和-v-的区别"><a href="#结构体打印时，-v-和-v-的区别" class="headerlink" title="结构体打印时，%v 和 %+v 的区别"></a>结构体打印时，<code>%v</code> 和 <code>%+v</code> 的区别</h1><p><code>%v</code>输出结构体各成员的值；</p><p><code>%+v</code>输出结构体各成员的名称和值；</p><p><code>%#v</code>输出结构体名称和结构体各成员的名称和值</p><h1 id="Go-语言中如何表示枚举值-enums-？"><a href="#Go-语言中如何表示枚举值-enums-？" class="headerlink" title="Go 语言中如何表示枚举值(enums)？"></a>Go 语言中如何表示枚举值(enums)？</h1><p>在常量中用iota可以表示枚举。iota从0开始。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">	B = 1 &lt;&lt; (10 * iota)</span><br><span class="line">	KiB </span><br><span class="line">	MiB</span><br><span class="line">	GiB</span><br><span class="line">	TiB</span><br><span class="line">	PiB</span><br><span class="line">	EiB</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="空-struct-的用途"><a href="#空-struct-的用途" class="headerlink" title="空 struct{} 的用途"></a>空 struct{} 的用途</h1><p>用map模拟一个set，那么就要把值置为struct{}，struct{}本身不占任何空间，可以避免任何多余的内存分配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type Set map[string]struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	set := make(Set)</span><br><span class="line">	for _, item := range []string&#123;&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125; &#123;</span><br><span class="line">		set[item] = struct&#123;&#125;&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(len(set)) // 3</span><br><span class="line">	if _, ok := set[&quot;A&quot;]; ok &#123;</span><br><span class="line">		fmt.Println(&quot;A exists&quot;) // A exists</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候给通道发送一个空结构体,channel&lt;-struct{}{}，也是节省了空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	ch := make(chan struct&#123;&#125;, 1)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		&lt;-ch</span><br><span class="line">		// do something</span><br><span class="line">	&#125;()</span><br><span class="line">	ch &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">	// ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅有方法的结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Lamp struct&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="go里面的int和int32是同一个概念吗？"><a href="#go里面的int和int32是同一个概念吗？" class="headerlink" title="go里面的int和int32是同一个概念吗？"></a>go里面的int和int32是同一个概念吗？</h1><p>不是一个概念！千万不能混淆。go语言中的int的大小是和操作系统位数相关的，如果是32位操作系统，int类型的大小就是4字节。如果是64位操作系统，int类型的大小就是8个字节。除此之外uint也与操作系统有关。</p><p>int8占1个字节，int16占2个字节，int32占4个字节，int64占8个字节。</p><h1 id="init-函数是什么时候执行的？"><a href="#init-函数是什么时候执行的？" class="headerlink" title="init() 函数是什么时候执行的？"></a>init() 函数是什么时候执行的？</h1><p>init()函数是go初始化的一部分，由runtime初始化每个导入的包，初始化不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。</p><p>每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的<code>init()</code>函数。同一个包，甚至是同一个源文件可以有多个<code>init()</code>函数。<code>init()</code>函数没有入参和返回值，不能被其他函数调用，同一个包内多个<code>init()</code>函数的执行顺序不作保证。</p><p>执行顺序：import –&gt; const –&gt; var –&gt;<code>init()</code>–&gt;<code>main()</code></p><p>一个文件可以有多个<code>init()</code>函数！</p><h1 id="如何知道一个对象是分配在栈上还是堆上？"><a href="#如何知道一个对象是分配在栈上还是堆上？" class="headerlink" title="如何知道一个对象是分配在栈上还是堆上？"></a>如何知道一个对象是分配在栈上还是堆上？</h1><p>Go和C++不同，Go局部变量会进行逃逸分析。如果变量离开作用域后没有被引用，则优先分配到栈上，否则分配到堆上。那么如何判断是否发生了逃逸呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags &#x27;-m -m -l&#x27; xxx.go</span><br></pre></td></tr></table></figure><p>关于逃逸的可能情况：变量大小不确定，变量类型不确定，变量分配的内存超过用户栈最大值，暴露给了外部指针。</p><h1 id="2-个-interface-可以比较吗-？"><a href="#2-个-interface-可以比较吗-？" class="headerlink" title="2 个 interface 可以比较吗 ？"></a>2 个 interface 可以比较吗 ？</h1><p>Go 语言中，interface 的内部实现包含了 2 个字段，类型 <code>T</code> 和 值 <code>V</code>，interface 可以使用 <code>==</code> 或 <code>!=</code> 比较。2 个 interface 相等有以下 2 种情况</p><ol><li>两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）</li><li>类型 T 相同，且对应的值 V 相等。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type Stu struct &#123;</span><br><span class="line">     Name string</span><br><span class="line">&#125;</span><br><span class="line">type StuInt interface&#123;&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">     var stu1, stu2 StuInt = &amp;Stu&#123;&quot;Tom&quot;&#125;, &amp;Stu&#123;&quot;Tom&quot;&#125;</span><br><span class="line">     var stu3, stu4 StuInt = Stu&#123;&quot;Tom&quot;&#125;, Stu&#123;&quot;Tom&quot;&#125;</span><br><span class="line">     fmt.Println(stu1 == stu2) // false</span><br><span class="line">     fmt.Println(stu3 == stu4) // true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>stu1</code> 和 <code>stu2</code> 对应的类型是 <code>*Stu</code>，值是 Stu 结构体的地址，两个地址不同，因此结果为 false。<br><code>stu3</code> 和 <code>stu4</code> 对应的类型是 <code>Stu</code>，值是 Stu 结构体，且各字段相等，因此结果为 true。</p><h1 id="2-个-nil-可能不相等吗？"><a href="#2-个-nil-可能不相等吗？" class="headerlink" title="2 个 nil 可能不相等吗？"></a>2 个 nil 可能不相等吗？</h1><p>可能不等。interface在运行时绑定值，只有值为nil接口值才为nil，但是与指针的nil不相等。举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var p *int = nil</span><br><span class="line">var i interface&#123;&#125; = nil</span><br><span class="line">if(p == i)&#123;</span><br><span class="line">	fmt.Println(&quot;Equal&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者并不相同。总结：两个nil只有在类型相同时才相等。</p><h1 id="函数返回局部变量的指针是否安全？"><a href="#函数返回局部变量的指针是否安全？" class="headerlink" title="函数返回局部变量的指针是否安全？"></a>函数返回局部变量的指针是否安全？</h1><p>这一点和C++不同，在Go里面返回局部变量的指针是安全的。因为Go会进行逃逸分析，如果发现局部变量的作用域超过该函数则会把指针分配到堆区，避免内存泄漏。</p><h1 id="非接口的任意类型-T-都能够调用-T-的方法吗？反过来呢？"><a href="#非接口的任意类型-T-都能够调用-T-的方法吗？反过来呢？" class="headerlink" title="非接口的任意类型 T() 都能够调用 *T 的方法吗？反过来呢？"></a>非接口的任意类型 T() 都能够调用 <code>*T</code> 的方法吗？反过来呢？</h1><p>一个T类型的值可以调用*T类型声明的方法，当且仅当T是可寻址的。</p><p>反之：*T 可以调用T()的方法，因为指针可以解引用。</p><h1 id="slice是怎么扩容的？"><a href="#slice是怎么扩容的？" class="headerlink" title="slice是怎么扩容的？"></a>slice是怎么扩容的？</h1><p>Go &lt;&#x3D; 1.17: 如果当前容量小于1024，则判断所需容量是否大于原来容量2倍，如果大于，当前容量加上所需容量；否则当前容量乘2。如果当前容量大于1024，则每次按照1.25倍速度递增容量，也就是每次加上cap&#x2F;4。</p><p>Go&gt;&#x3D;1.18:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums := []int&#123;1, 2&#125;</span><br><span class="line">nums = append(nums, 2, 3, 4)</span><br></pre></td></tr></table></figure><p>此时<code>old.cap = 2</code>，容量至少为<code>cap=5</code>，那么就简单的扩容让<code>cap=5</code>了吗？</p><p>在 <code>src/runtime/slice.go</code>的166行处定义了扩容<code>slice</code>的函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func growslice(et *_type, old slice, cap int) slice &#123;</span><br><span class="line">	//</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算预估容量newcap</p><table><thead><tr><th>变量</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>old.cap</td><td>扩容前切片容量</td><td></td></tr><tr><td>newcap</td><td>预估容量</td><td>默认为扩容前切片容量(old.cap)</td></tr><tr><td>cap</td><td>扩容后至少需要的最小容量</td><td><code>old.cap</code> + 本次新增的元素数量</td></tr><tr><td>doublecap</td><td>扩容前切片的2倍容量</td><td>old.cap * 2</td></tr></tbody></table><p>其中,当扩容前容量 &gt;&#x3D; 256时，会按照公式进行扩容，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newcap += (newcap + <span class="number">3</span>*threshold) / <span class="number">4</span></span><br></pre></td></tr></table></figure><p>回到1.18案例代码进行解释：old.cap &#x3D; 2, cap &#x3D; 2 + 3 &#x3D; 5，那么由于 cap &gt; old.cap *2 ，所以预估容量 newcap &#x3D; cap &#x3D; 5</p><h1 id="为什么有协程泄露-Goroutine-Leak-？"><a href="#为什么有协程泄露-Goroutine-Leak-？" class="headerlink" title="为什么有协程泄露(Goroutine Leak)？"></a>为什么有协程泄露(Goroutine Leak)？</h1><p>协程泄漏是指协程创建之后没有得到释放。主要原因有：</p><ol><li>缺少接收器，导致发送阻塞</li><li>缺少发送器，导致接收阻塞</li><li>死锁。多个协程由于竞争资源导致死锁。</li><li>创建协程的没有回收。</li></ol><h1 id="Go-可以限制运行时操作系统线程的数量吗？-常见的goroutine操作函数有哪些？"><a href="#Go-可以限制运行时操作系统线程的数量吗？-常见的goroutine操作函数有哪些？" class="headerlink" title="Go 可以限制运行时操作系统线程的数量吗？ 常见的goroutine操作函数有哪些？"></a>Go 可以限制运行时操作系统线程的数量吗？ 常见的goroutine操作函数有哪些？</h1><p>可以，使用runtime.GOMAXPROCS(num int)可以设置线程数目。该值默认为CPU逻辑核数，如果设的太大，会引起频繁的线程切换，降低性能。</p><p>runtime.Gosched()，用于让出CPU时间片，让出当前goroutine的执行权限，调度器安排其它等待的任务运行，并在下次某个时候从该位置恢复执行。<br>runtime.Goexit()，调用此函数会立即使当前的goroutine的运行终止（终止协程），而其它的goroutine并不会受此影响。runtime.Goexit在终止当前goroutine前会先执行此goroutine的还未执行的defer语句。请注意千万别在主函数调用runtime.Goexit，因为会引发panic。</p><h1 id="如何控制协程数目。"><a href="#如何控制协程数目。" class="headerlink" title="如何控制协程数目。"></a>如何控制协程数目。</h1><blockquote><p>The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit.</p></blockquote><p>从官方文档的解释可以看到，<code>GOMAXPROCS</code> 限制的是同时执行用户态 Go 代码的操作系统线程的数量，但是对于被系统调用阻塞的线程数量是没有限制的。<code>GOMAXPROCS</code> 的默认值等于 CPU 的逻辑核数，同一时间，一个核只能绑定一个线程，然后运行被调度的协程。因此对于 CPU 密集型的任务，若该值过大，例如设置为 CPU 逻辑核数的 2 倍，会增加线程切换的开销，降低性能。对于 I&#x2F;O 密集型应用，适当地调大该值，可以提高 I&#x2F;O 吞吐率。</p><p>可以用带缓冲区的channel来控制，下面的例子是协程数为1024的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var wg sync.WaitGroup</span><br><span class="line">ch := make(chan struct&#123;&#125;, 1024)</span><br><span class="line">for i:=0; i&lt;20000; i++&#123;</span><br><span class="line">	wg.Add(1)</span><br><span class="line">	ch&lt;-struct&#123;&#125;&#123;&#125;</span><br><span class="line">	go func()&#123;</span><br><span class="line">		defer wg.Done()</span><br><span class="line">		&lt;-ch</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><h1 id="new和make的区别？"><a href="#new和make的区别？" class="headerlink" title="new和make的区别？"></a>new和make的区别？</h1><p>new只用于分配内存，返回一个指向地址的指针。它为每个新类型分配一片内存，初始化为0且返回类型*T的内存地址，它相当于&amp;T{}</p><p>make只可用于slice,map,channel的初始化,返回的是引用。</p><h1 id="请你讲一下Go面向对象是如何实现的？"><a href="#请你讲一下Go面向对象是如何实现的？" class="headerlink" title="请你讲一下Go面向对象是如何实现的？"></a>请你讲一下Go面向对象是如何实现的？</h1><p>Go实现面向对象的两个关键是struct和interface。</p><p>封装：对于同一个包，对象对包内的文件可见；对不同的包，需要将对象以大写开头才是可见的。</p><p>继承：继承是编译时特征，在struct内加入所需要继承的类即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type A struct&#123;&#125;</span><br><span class="line">type B struct&#123;</span><br><span class="line">A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多态：多态是运行时特征，Go多态通过interface来实现。类型和接口是松耦合的，某个类型的实例可以赋给它所实现的任意接口类型的变量。</p><p>Go支持多重继承，就是在类型中嵌入所有必要的父类型。</p><h1 id="uint型变量值分别为-1，2，它们相减的结果是多少？"><a href="#uint型变量值分别为-1，2，它们相减的结果是多少？" class="headerlink" title="uint型变量值分别为 1，2，它们相减的结果是多少？"></a>uint型变量值分别为 1，2，它们相减的结果是多少？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	var a uint = 1</span><br><span class="line">	var b uint = 2</span><br><span class="line">	fmt.Println(a - b)</span><br><span class="line">&#125;</span><br><span class="line">//18446744073709551615</span><br></pre></td></tr></table></figure><p>答案，结果会溢出，如果是32位系统，结果是2^32-1，如果是64位系统，结果2^64-1.</p><h1 id="讲一下go有没有函数在main之前执行？怎么用？"><a href="#讲一下go有没有函数在main之前执行？怎么用？" class="headerlink" title="讲一下go有没有函数在main之前执行？怎么用？"></a>讲一下go有没有函数在main之前执行？怎么用？</h1><p>go的init函数在main函数之前执行，它有如下特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func init() &#123;</span><br><span class="line">	//TODO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始化不能采用初始化表达式初始化的变量；</li><li>程序运行前执行注册</li><li>实现sync.Once功能</li><li>不能被其它函数调用</li><li>init函数没有入口参数和返回值：</li><li>每个包可以有多个init函数，每个源文件也可以有多个init函数。</li><li>同一个包的init执行顺序，golang没有明确定义，编程时要注意程序不要依赖这个执行顺序。</li><li>不同包的init函数按照包导入的依赖关系决定执行顺序。</li></ul><h1 id="下面这句代码是什么作用，为什么要定义一个空值？"><a href="#下面这句代码是什么作用，为什么要定义一个空值？" class="headerlink" title="下面这句代码是什么作用，为什么要定义一个空值？"></a>下面这句代码是什么作用，为什么要定义一个空值？</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type GobCodec struct&#123;</span><br><span class="line">	conn io.ReadWriteCloser</span><br><span class="line">	buf *bufio.Writer</span><br><span class="line">	dec *gob.Decoder</span><br><span class="line">	enc *gob.Encoder</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Codec interface &#123;</span><br><span class="line">	io.Closer</span><br><span class="line">	ReadHeader(*Header) error</span><br><span class="line">	ReadBody(interface&#123;&#125;)  error</span><br><span class="line">	Write(*Header, interface&#123;&#125;) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var _ Codec = (*GobCodec)(nil)</span><br></pre></td></tr></table></figure><p>答：将nil转换为<em>GobCodec类型，然后再转换为Codec接口，如果转换失败，说明</em>GobCodec没有实现Codec接口的所有方法。</p><h1 id="mutex有几种模式？"><a href="#mutex有几种模式？" class="headerlink" title="mutex有几种模式？"></a>mutex有几种模式？</h1><p>mutex有两种模式：normal 和 starvation</p><p>正常模式：所有goroutine按照FIFO的顺序进行锁获取，被唤醒的goroutine和新请求锁的goroutine同时进行锁获取，通常新请求锁的goroutine更容易获取锁(持续占有cpu)，被唤醒的goroutine则不容易获取到锁。公平性：否。</p><p>饥饿模式：所有尝试获取锁的goroutine进行等待排队，新请求锁的goroutine不会进行锁获取(禁用自旋)，而是加入队列尾部等待获取锁。公平性：是。</p><h1 id="Go什么时候发生阻塞？阻塞时，调度器会怎么做。"><a href="#Go什么时候发生阻塞？阻塞时，调度器会怎么做。" class="headerlink" title="Go什么时候发生阻塞？阻塞时，调度器会怎么做。"></a>Go什么时候发生阻塞？阻塞时，调度器会怎么做。</h1><ul><li>用于原子、互斥量或通道操作导致goroutine阻塞，调度器将把当前阻塞的goroutine从本地运行队列LRQ换出，并重新调度其它goroutine；</li><li>由于网络请求和IO导致的阻塞，Go提供了网络轮询器（Netpoller）来处理，后台用epoll等技术实现IO多路复用。</li></ul><p>其它回答：</p><ul><li>channel阻塞：当goroutine读写channel发生阻塞时，会调用gopark函数，该G脱离当前的M和P，调度器将新的G放入当前M。</li><li>系统调用：当某个G由于系统调用陷入内核态，该P就会脱离当前M，此时P会更新自己的状态为Psyscall，M与G相互绑定，进行系统调用。结束以后，若该P状态还是Psyscall，则直接关联该M和G，否则使用闲置的处理器处理该G。</li><li>系统监控：当某个G在P上运行的时间超过10ms时候，或者P处于Psyscall状态过长等情况就会调用retake函数，触发新的调度。</li><li>主动让出：由于是协作式调度，该G会主动让出当前的P（通过GoSched），更新状态为Grunnable，该P会调度队列中的G运行。</li></ul><h1 id="如果有一个G一直占用资源怎么办？什么是work-stealing算法？"><a href="#如果有一个G一直占用资源怎么办？什么是work-stealing算法？" class="headerlink" title="如果有一个G一直占用资源怎么办？什么是work stealing算法？"></a>如果有一个G一直占用资源怎么办？什么是work stealing算法？</h1><p>如果有个goroutine一直占用资源，那么GMP模型会从正常模式转变为饥饿模式（类似于mutex），允许其它goroutine使用work stealing抢占（禁用自旋锁）。</p><p>work stealing算法指，一个线程如果处于空闲状态，则帮其它正在忙的线程分担压力，从全局队列取一个G任务来执行，可以极大提高执行效率。</p><h1 id="goroutine什么情况会发生内存泄漏？如何避免。"><a href="#goroutine什么情况会发生内存泄漏？如何避免。" class="headerlink" title="goroutine什么情况会发生内存泄漏？如何避免。"></a>goroutine什么情况会发生内存泄漏？如何避免。</h1><p>在Go中内存泄露分为暂时性内存泄露和永久性内存泄露。</p><p>暂时性内存泄露</p><ul><li>获取长字符串中的一段导致长字符串未释放</li><li>获取长slice中的一段导致长slice未释放</li><li>在长slice新建slice导致泄漏</li></ul><p>string相比切片少了一个容量的cap字段，可以把string当成一个只读的切片类型。获取长string或者切片中的一段内容，由于新生成的对象和老的string或者切片共用一个内存空间，会导致老的string和切片资源暂时得不到释放，造成短暂的内存泄漏</p><p>永久性内存泄露</p><ul><li>goroutine永久阻塞而导致泄漏</li><li>time.Ticker未关闭导致泄漏</li><li>不正确使用Finalizer（Go版本的析构函数）导致泄漏</li></ul><h1 id="go竞态条件了解吗？"><a href="#go竞态条件了解吗？" class="headerlink" title="go竞态条件了解吗？"></a>go竞态条件了解吗？</h1><p>所谓竞态竞争，就是当两个或以上的goroutine访问相同资源时候，对资源进行读&#x2F;写。</p><p>比如<code>var a int = 0</code>，有两个协程分别对a+&#x3D;1，我们发现最后a不一定为2.这就是竞态竞争。</p><p>通常我们可以用<code>go run -race xx.go</code>来进行检测。</p><p>解决方法是，对临界区资源上锁，或者使用原子操作(atomics)，原子操作的开销小于上锁。</p><h1 id="如果若干个goroutine，有一个panic会怎么做？"><a href="#如果若干个goroutine，有一个panic会怎么做？" class="headerlink" title="如果若干个goroutine，有一个panic会怎么做？"></a>如果若干个goroutine，有一个panic会怎么做？</h1><p>有一个panic，那么剩余goroutine也会退出，程序退出。如果不想程序退出，那么必须通过调用 recover() 方法来捕获 panic 并恢复将要崩掉的程序。</p><h1 id="defer可以捕获goroutine的子goroutine吗？"><a href="#defer可以捕获goroutine的子goroutine吗？" class="headerlink" title="defer可以捕获goroutine的子goroutine吗？"></a>defer可以捕获goroutine的子goroutine吗？</h1><p>不可以。它们处于不同的调度器P中。对于子goroutine，必须通过 recover() 机制来进行恢复，然后结合日志进行打印（或者通过channel传递error），下面是一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 心跳函数</span><br><span class="line">func Ping(ctx context.Context) error &#123;</span><br><span class="line">    ... code ...</span><br><span class="line"> </span><br><span class="line">	go func() &#123;</span><br><span class="line">		defer func() &#123;</span><br><span class="line">			if r := recover(); r != nil &#123;</span><br><span class="line">				log.Errorc(ctx, &quot;ping panic: %v, stack: %v&quot;, r, string(debug.Stack()))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line"> </span><br><span class="line">        ... code ...</span><br><span class="line">	&#125;()</span><br><span class="line"> </span><br><span class="line">    ... code ...</span><br><span class="line"> </span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="channel-死锁的场景"><a href="#channel-死锁的场景" class="headerlink" title="channel 死锁的场景"></a>channel 死锁的场景</h1><ul><li>当一个<code>channel</code>中没有数据，而直接读取时，会发生死锁：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q := make(chan int,2)</span><br><span class="line">&lt;-q</span><br></pre></td></tr></table></figure><p>解决方案是采用select语句，再default放默认处理方式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">q := make(chan int,2)</span><br><span class="line">select&#123;</span><br><span class="line">   case val:=&lt;-q:</span><br><span class="line">   default:</span><br><span class="line">         ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当channel数据满了，再尝试写数据会造成死锁：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">q := make(chan int,2)</span><br><span class="line">q&lt;-1</span><br><span class="line">q&lt;-2</span><br><span class="line">q&lt;-3</span><br></pre></td></tr></table></figure><p>解决方法，采用select</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	q := make(chan int, 2)</span><br><span class="line">	q &lt;- 1</span><br><span class="line">	q &lt;- 2</span><br><span class="line">	select &#123;</span><br><span class="line">	case q &lt;- 3:</span><br><span class="line">		fmt.Println(&quot;ok&quot;)</span><br><span class="line">	default:</span><br><span class="line">		fmt.Println(&quot;wrong&quot;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>向一个关闭的channel写数据。</li></ul><p>注意：一个已经关闭的channel，只能读数据，不能写数据。</p><h1 id="对已经关闭的chan进行读写会怎么样？"><a href="#对已经关闭的chan进行读写会怎么样？" class="headerlink" title="对已经关闭的chan进行读写会怎么样？"></a>对已经关闭的chan进行读写会怎么样？</h1><ul><li>读已经关闭的chan能一直读到东西，但是读到的内容根据通道内关闭前是否有元素而不同。</li><li>如果chan关闭前，buffer内有元素还未读,会正确读到chan内的值，且返回的第二个bool值（是否读成功）为true。</li><li>如果chan关闭前，buffer内有元素已经被读完，chan内无值，接下来所有接收的值都会非阻塞直接成功，返回 channel 元素的零值，但是第二个bool值一直为false。</li></ul><p>写已经关闭的chan会panic。</p><h3 id="进程被kill，如何保证所有goroutine顺利退出"><a href="#进程被kill，如何保证所有goroutine顺利退出" class="headerlink" title="进程被kill，如何保证所有goroutine顺利退出"></a>进程被kill，如何保证所有goroutine顺利退出</h3><p>goroutine监听SIGKILL信号，一旦接收到SIGKILL，则立刻退出。可采用select方法。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var wg = &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	wg.Add(1)</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		c1 := make(chan os.Signal, 1)</span><br><span class="line">		signal.Notify(c1, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT)</span><br><span class="line">		fmt.Printf(&quot;goroutine 1 receive a signal : %v\n\n&quot;, &lt;-c1)</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Printf(&quot;all groutine done!\n&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说说context包的作用？你用过哪些，原理知道吗？"><a href="#说说context包的作用？你用过哪些，原理知道吗？" class="headerlink" title="说说context包的作用？你用过哪些，原理知道吗？"></a>说说context包的作用？你用过哪些，原理知道吗？</h3><p><code>context</code>可以用来在<code>goroutine</code>之间传递上下文信息，相同的<code>context</code>可以传递给运行在不同<code>goroutine</code>中的函数，上下文对于多个<code>goroutine</code>同时使用是安全的，<code>context</code>包定义了上下文类型，可以使用<code>background</code>、<code>TODO</code>创建一个上下文，在函数调用链之间传播<code>context</code>，也可以使用<code>WithDeadline</code>、<code>WithTimeout</code>、<code>WithCancel</code> 或 <code>WithValue</code> 创建的修改副本替换它，听起来有点绕，其实总结起就是一句话：<code>context</code>的作用就是在不同的<code>goroutine</code>之间同步请求特定的数据、取消信号以及处理请求的截止日期。</p><h1 id="说说-atomic底层怎么实现的"><a href="#说说-atomic底层怎么实现的" class="headerlink" title="说说 atomic底层怎么实现的."></a>说说 atomic底层怎么实现的.</h1><p>atomic源码位于<code>sync\atomic</code>。通过阅读源码可知，atomic采用CAS（CompareAndSwap）的方式实现的。所谓CAS就是使用了CPU中的原子性操作。在操作共享变量的时候，CAS不需要对其进行加锁，而是通过类似于乐观锁的方式进行检测，总是假设被操作的值未曾改变（即与旧值相等），并一旦确认这个假设的真实性就立即进行值替换。本质上是不断占用CPU资源来避免加锁的开销。</p><h1 id="channel底层实现？是否线程安全。"><a href="#channel底层实现？是否线程安全。" class="headerlink" title="channel底层实现？是否线程安全。"></a>channel底层实现？是否线程安全。</h1><p>channel底层实现在<code>src/runtime/chan.go</code>中</p><p>channel内部是一个循环链表。内部包含buf, sendx, recvx, lock ,recvq, sendq几个部分；</p><ul><li>buf是有缓冲的channel所特有的结构，用来存储缓存数据。是个循环链表；</li><li>sendx和recvx用于记录buf这个循环链表中的发送或者接收的index；</li><li>lock是个互斥锁；</li><li>recvq和sendq分别是接收(&lt;-channel)或者发送(channel &lt;- xxx)的goroutine抽象出来的结构体(sudog)的队列。是个双向链表。</li></ul><h1 id="map的底层实现。"><a href="#map的底层实现。" class="headerlink" title="map的底层实现。"></a>map的底层实现。</h1><p>源码位于<code>src\runtime\map.go</code> 中。</p><p>go的map和C++map不一样，底层实现是哈希表，包括两个部分：hmap和bucket。</p><p>里面最重要的是buckets（桶），buckets是一个指针，最终它指向的是一个结构体：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// A bucket for a Go map.</span><br><span class="line">type bmap struct &#123;</span><br><span class="line">    tophash [bucketCnt]uint8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个bucket固定包含8个key和value(可以查看源码bucketCnt&#x3D;8).实现上面是一个固定的大小连续内存块，分成四部分：每个条目的状态，8个key值，8个value值，指向下个bucket的指针。</p><p>创建哈希表使用的是<code>makemap</code>函数.map 的一个关键点在于，哈希函数的选择。在程序启动时，会检测 cpu 是否支持 aes，如果支持，则使用 aes hash，否则使用 memhash。这是在函数 alginit() 中完成，位于路径：<code>src/runtime/alg.go</code> 下。</p><p>map查找就是将key哈希后得到64位（64位机）用最后B个比特位计算在哪个桶。在 bucket 中，从前往后找到第一个空位。这样，在查找某个 key 时，先找到对应的桶，再去遍历 bucket 中的 key。</p><h1 id="select的实现原理？"><a href="#select的实现原理？" class="headerlink" title="select的实现原理？"></a>select的实现原理？</h1><p>select源码位于<code>src\runtime\select.go</code>，最重要的<code>scase</code> 数据结构为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type scase struct &#123;</span><br><span class="line">	c    *hchan         // chan</span><br><span class="line">	elem unsafe.Pointer // data element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scase.c为当前case语句所操作的channel指针，这也说明了一个case语句只能操作一个channel。</p><p>scase.elem表示缓冲区地址：</p><ul><li>caseRecv ： scase.elem表示读出channel的数据存放地址；</li><li>caseSend ： scase.elem表示将要写入channel的数据存放地址；</li></ul><p>select的主要实现位于：<code>select.go</code>函数：其主要功能如下：</p><ol><li>锁定scase语句中所有的channel</li><li>按照随机顺序检测scase中的channel是否ready</li></ol><p>2.1 如果case可读，则读取channel中数据，解锁所有的channel，然后返回(case index, true)</p><p>2.2 如果case可写，则将数据写入channel，解锁所有的channel，然后返回(case index, false)</p><p>2.3 所有case都未ready，则解锁所有的channel，然后返回（default index, false）</p><ol start="3"><li>所有case都未ready，且没有default语句</li></ol><p>3.1 将当前协程加入到所有channel的等待队列</p><p>3.2 当将协程转入阻塞，等待被唤醒</p><ol start="4"><li>唤醒后返回channel对应的case index</li></ol><p>4.1 如果是读操作，解锁所有的channel，然后返回(case index, true)</p><p>4.2 如果是写操作，解锁所有的channel，然后返回(case index, false)</p><h1 id="go的interface怎么实现的？"><a href="#go的interface怎么实现的？" class="headerlink" title="go的interface怎么实现的？"></a>go的interface怎么实现的？</h1><p>go interface源码在<code>runtime\iface.go</code>中。</p><p>go的接口由两种类型实现<code>iface</code>和<code>eface</code>。iface是包含方法的接口，而eface不包含方法。</p><ul><li><code>iface</code></li></ul><p>对应的数据结构是（位于<code>src\runtime\runtime2.go</code>）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type iface struct &#123;</span><br><span class="line">	tab  *itab</span><br><span class="line">	data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以简单理解为，tab表示接口的具体结构类型，而data是接口的值。</p><ul><li>itab：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type itab struct &#123;</span><br><span class="line">	inter *interfacetype //此属性用于定位到具体interface</span><br><span class="line">	_type *_type //此属性用于定位到具体interface</span><br><span class="line">	hash  uint32 // copy of _type.hash. Used for type switches.</span><br><span class="line">	_     [4]byte</span><br><span class="line">	fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性<code>interfacetype</code>类似于<code>_type</code>，其作用就是interface的公共描述，类似的还有<code>maptype</code>、<code>arraytype</code>、<code>chantype</code>…其都是各个结构的公共描述，可以理解为一种外在的表现信息。interfaetype和type唯一确定了接口类型，而hash用于查询和类型判断。fun表示方法集。</p><ul><li><code>eface</code></li></ul><p>与iface基本一致，但是用<code>_type</code>直接表示类型，这样的话就无法使用方法。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type eface struct &#123;</span><br><span class="line">	_type *_type</span><br><span class="line">	data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="go的reflect-底层实现"><a href="#go的reflect-底层实现" class="headerlink" title="go的reflect 底层实现"></a>go的reflect 底层实现</h1><p>go reflect源码位于<code>src\reflect\</code>下面，作为一个库独立存在。反射是基于接口实现的。</p><p>Go反射有三大法则：</p><ul><li>反射从接口映射到反射对象；</li><li>反射从反射对象映射到接口值；</li><li>只有值可以修改(settable)，才可以修改反射对象。</li></ul><p>Go反射基于上述三点实现。我们先从最核心的两个源文件入手<code>type.go</code>和<code>value.go</code>.</p><p>type用于获取当前值的类型。value用于获取当前的值。</p><h1 id="简述-Go-语言GC-垃圾回收-的工作原理"><a href="#简述-Go-语言GC-垃圾回收-的工作原理" class="headerlink" title="简述 Go 语言GC(垃圾回收)的工作原理"></a>简述 Go 语言GC(垃圾回收)的工作原理</h1><p>垃圾回收机制是Go一大特(nan)色(dian)。Go1.3采用标记清除法， Go1.5采用三色标记法，Go1.8采用三色标记法+混合写屏障。</p><p>*标记清除法*</p><p>分为两个阶段：标记和清除</p><p>标记阶段：从根对象出发寻找并标记所有存活的对象。</p><p>清除阶段：遍历堆中的对象，回收未标记的对象，并加入空闲链表。</p><p>缺点是需要暂停程序STW。</p><p>*三色标记法*：</p><p>将对象标记为白色，灰色或黑色。</p><p>白色：不确定对象（默认色）；黑色：存活对象。灰色：存活对象，子对象待处理。</p><p>标记开始时，先将所有对象加入白色集合（需要STW）。首先将根对象标记为灰色，然后将一个对象从灰色集合取出，遍历其子对象，放入灰色集合。同时将取出的对象放入黑色集合，直到灰色集合为空。最后的白色集合对象就是需要清理的对象。</p><p>这种方法有一个缺陷，如果对象的引用被用户修改了，那么之前的标记就无效了。因此Go采用了写屏障技术，当对象新增或者更新会将其着色为灰色。</p><p>一次完整的GC分为四个阶段：</p><ol><li>准备标记（需要STW），开启写屏障。</li><li>开始标记</li><li>标记结束（STW），关闭写屏障</li><li>清理（并发）</li></ol><p>基于插入写屏障和删除写屏障在结束时需要STW来重新扫描栈，带来性能瓶颈。混合写屏障分为以下四步：</p><ol><li>GC开始时，将栈上的全部对象标记为黑色（不需要二次扫描，无需STW）；</li><li>GC期间，任何栈上创建的新对象均为黑色</li><li>被删除引用的对象标记为灰色</li><li>被添加引用的对象标记为灰色</li></ol><p>总而言之就是确保黑色对象不能引用白色对象，这个改进直接使得GC时间从 2s降低到2us。</p><p></p></div><hr class="layui-border-orange"></div></div><style>.layui-content table{border-collapse:collapse;border-spacing:0;margin:10px 0;display:table}.layui-content table td,table th{padding:10px;border:1px solid #ddd;color:#333;vertical-align:middle;word-break:normal!important}.layui-content table .gutter{display:none}.layui-content figure.highlight{margin:15px 0;background:#e3e3e3;padding:0;line-height:24px;overflow-x:auto}.layui-content figure.highlight table td{border:0}.layui-content blockquote{margin:15px 0;background:#e3e3e3;border-left:3px solid #5fb878;padding:10px 0 0 20px}.layui-content ol li{margin-bottom:10px;list-style:decimal;margin-left:10px}.layui-content ul li{margin-bottom:10px;list-style:inside;margin-left:10px}.layui-content code{background-color:#e3e3e3}.layui-content a{text-decoration:underline;color:#1e9fff}body img{max-width:100%}</style></div></div></div><div class="footer"><p><span>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> </span><span>| </span><span>Theme - <a href="https://github.com/zzqqw/hexo-theme-xianxin" target="_blank">xianxin</a></span></p><p><span>&copy; 2024</span> <span>MIT license</span></p><script async src="https://www.googletagmanager.com/gtag/js?id=G-TBH6G20B8Y"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-TBH6G20B8Y")</script></div></body></html>